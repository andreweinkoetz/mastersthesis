\section{Design Goals}
\label{sec:DesignGoals}

The main purpose of our system is to facilitate the evolution process of Web APIs. Therefore, it must meet several requirements in order to be of real benefit to all actors involved. Some of these requirements are not complementary but contradict each other. In order to achieve the best possible result for our users, we prioritize our design decisions in the following section.

\paragraph{Dependability Criteria}
Decisions about the dependability of the system concern the effort to be invested in minimizing system crashes and their effects on users \cite{bruegge_object-oriented_2010}. Integrating our system into the CI/CD pipeline of an application means that subsequent process steps rely on its error-free execution. Emphasis is therefore on \ref{nfr:TestCoverage} which implies creating extensive tests of the migration logic, especially with regard to edge cases. In addition, incorrect user input must be handled and detailed error messages must be provided so that users can identify and correct errors themselves. By prioritizing robustness and fault tolerance, the delivery time for new functionality in our system such as additional language or API type support is significantly extended. 

Furthermore, client applications rely on an error-free execution of the code emitted by our system. Therefore, the resulting library code needs to handle internal errors appropriately and forward any response emitted by the Web API.  As It is designed to mirror the behavior of the Web API, also any errors that are issued by the Web API are returned to the requesting method within client code. Hence, client developers are responsible for handling errors appropriately and designing their application for failures. 

\paragraph{Performance Criteria}
Achieving high performance measures is not an essential requirement of our system as it runs as a background process in an application's CI/CD pipeline or in a user's local terminal. While users do not depend on fast response times or a high throughput, the memory usage of our system increases with the size of the IDL document or migration manual. Therefore, when designing the system architecture, care should be taken that memory-intensive components are encapsulated in order to replace them with more efficient algorithms if necessary. In terms of the library code generated, our design choices \ref{fr:Facade} and \ref{fr:AdaptFacade} result in decreased performance for client applications as API requests and responses must be processed across multiple layers.

\paragraph{Maintenance Criteria}
According to Bruegge et. al, maintenance design decisions determine the difficulty of changing a system after its initial deployment \cite{bruegge_object-oriented_2010}. Well-defined subsystems that enable a clear separation of concerns ensure that our system maintains a high degree of extensibility and modifiability. In particular, components concerned with the language-specific generation of libraries or the import of different types of IDLs must be designed with strict consideration of extensibility. This is due to the fact that supporting more languages and types of APIs is critical to increasing our system's adoption and adding additional value to its users. The encapsulation of language or API-specific functionality also improves the modifiability of our system by limiting changes due to external influences to the corresponding component. 

Focussing on expandability and modifiability involves a trade-off in terms of portability and adaptability. Adapting the system to another application domain like for example managing API evolution for providers is not intended. Furthermore, the support of different types of language-specific library generation for several Web API styles increases the complexity of the system, which means that the effort for new maintainers to understand the system is increased and porting it to other platforms like using a different host language becomes more complicated. 

Although we do not consider any cost criteria in this thesis, it is important to note that our maintenance criteria together with an extensive testing result in longer delivery times with significantly higher costs for development and maintenance. Using the output of our systems, on the other hand, reduces development costs and delivery times of client applications, as switching between different API types and programming languages is frictionless, an according implementation of our system implied. In order to be able to use the generated code for a different application domain, programming language or API type, our system just requires the corresponding parameters and does not need any adaptation of its functionality.

\paragraph{End User Criteria}
Reducing the manual overhead of evolution for Web API consumers is the main goal of our proposed system. Automating the workflow for migrating client applications adds an additional task for Web API providers. By requiring them to specify all changes in a migration guide for each release, the effort of consumers is shifted to the provider side. This design decision was made based on the assumption that future research can concentrate on automating the creation of a migration guide for Web API providers. Related research as shown in section \ref{sec:APIEvolutionAutomation} demonstrates how capturing and replaying or diffing techniques can be used to realize possible scenarios like scenario \ref{subsubsec:Scenario:graphQLScenario}. In addition, the number of consumers of public Web APIs is exceeding their providers, resulting in an overall reduction in maintenance effort. 

In order to maximize the positive impact of the system, special attention is paid to its usability for Web API consumers. Non-functional requirements were specified for coloring of key output messages (\ref{nfr:Coloring}), documentation of generated library code (\ref{nfr:ClientDocumentation}) and provision of help messages (\ref{nfr:Help}) to ensure a high degree of usabilitys. All of the code emitted by our system is documented by code comments that explain how to use the Web API thus facilitating learning for users.