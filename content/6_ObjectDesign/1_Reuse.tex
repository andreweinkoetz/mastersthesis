\section{Reuse}
\label{sec:Reuse}

 Software reuse increases the productivity of development teams and improves the overall quality of the product. Therefore, our proposed system defines several components that can be reused from existing solutions. All external components must be open-sourced under the MIT license in order to fulfill our legal requirements (\ref{nfr:Legal}). Furthermore, custom components of subsystems can be implemented by reusing pattern solutions as defined by the \ac{GoF}. 
 
 Tooling to parse an IDL specification and generate library code for various programming languages is available for many modern Web APIs. For REST-based Web APIs, the OpenAPI Generator\footnote{https://openapi-generator.tech/} is an open-source tool that can be integrated in existing Java projects via Maven/Gradle plugins, or used via CLI and an online service\footnote{http://api.openapi-generator.tech/index.html}. It supports parsing of OpenAPI IDLs regardless of whether they were encoded to YAML or JSON. Additionally, it generates library code in 65 programming languages and dialects. Google's gRPC\footnote{https://grpc.io/} technology uses protocol buffers as an IDL and as a format for exchanging messages. Parsing protocol buffers and generating library code is currently available for 16 programming languages and dialects, with support for additional languages upcoming. Emerging GraphQL\footnote{https://graphql.org/} APIs are described by the \ac{SDL} for which different tools exist that are able to generate library code from it. On the one hand, the GraphQL code generator\footnote{https://graphql-code-generator.com/} supports five programming languages and offers several configuration options to further customize the emitted code. Quicktype\footnote{https://quicktype.io/}, on the other hand, supports 19 programming languages and similar configuration options. One limitation of all tools above is their Integratability as a framework. They are designed to generate library code persisted in files, which prevents developers from accessing intermediate artifacts like the decoded IDL document. Generating source code in a programming language that is not supported by those tools requires forking the codebase to extend their functionality. However, for some IDLs and programming languages new frameworks are published that can be integrated into existing projects to get access to intermediate artifacts. For example, the OpenAPIKit\footnote{https://github.com/mattpolzin/OpenAPIKit} is an open-source project that offers a Swift library to en-/decode OpenAPI IDL documents. By separating the parsing of an IDL document and the subsequent library generation, the extensibility for new programming languages and IDL types is considerably increased. 
 
 Supporting multiple programming languages is also a challenge for the \texttt{Source\-Code} \texttt{Importer} subsystem. It must support parsing source code of a programming language into its \ac{AST}. Tools are available for most programming languages as many features of \acp{IDE}, such as syntax highlighting or auto-completion rely on them. However, most of these tools are commercial products and are not available under an open-source licence. One example is the JavaParser\footnote{https://javaparser.org/} which is available as a Maven and Gradle plugin for parsing, analyzing and generating Java code. Other frameworks were created through the active contribution of open-source communities. Acorn\footnote{https://github.com/acornjs/acorn} is a parser for JavaScript code that supports plugins for JavaScript dialects and frameworks like React JSX. Sourcery\footnote{https://github.com/krzysztofzablocki/Sourcery} is a Swift library that provides an \ac{API} that offers parsing and generating Swift code based on Stencil templates. All of these frameworks are limited to parsing source code of a single programming language. To support many different languages simultaneously, custom lexers and parsers must be specified and implemented for each language. While this is a cumbersome manual effort, tools like \ac{ANTLR}\footnote{https://www.antlr.org/} enable developers to generate lexers and parsers in Java, C\#, C++, JavaScript, Python, Swift and Go. Therefore, users have to provide a grammar of the language that describes its structure. This grammar is defined using the Antlr4 grammar syntax. The application's repository contains over 200 predefined grammars that cover many modern programming languages.
 
 Our system uses a machine-readable migration guide to collect all changes that were introduced between subsequent versions of a Web API. In order to fulfill \ref{nfr:MigGuideFormat}, it should be using a \ac{DSL} that is in a human-readable format which is prevalent in the context of web development. While an implementation in a custom language using the auxiliary features of ANTLR would be conceivable, we advocate the use of \ac{JSON} as an external, compositional DSL. This decision is based on the fact that JSON is not just easy to understand and learn, but is also an established standard that is widely adopted by web developers. Another key advantage comes from existing utility libraries for parsing JSON documents in many programming languages. As they are either part of core libraries or can be integrated using third-party open-source frameworks, the need to use a custom built lexer and parser is eliminated. Listing \ref{lst:exampleGuide} shows an example JSON-based migration guide that contains one change and specifies some meta-information.
 
 \vspace{2mm}
 \begin{lstlisting}[language=json, caption={Examplatory migration guide in JSON format}, captionpos=b, label={lst:exampleGuide}]
 	{
 		"summary" : "This is an examplatory migration guide.",
 		"api-spec": "OpenAPI",
 		"from-version" : "0.0.1b",
 		"to-version" : "0.0.2",
 		"changes" : [
	 		{
	 			"reason": "Default value was added.",
	 			"object" : {
	 				"operation-id" : "findPetsByStatus",
	 				"defined-in" : "/pet"
	 			},
	 			"target" : "Content-Body",
	 			"added" : [
		 			{
		 				"name" : "_",
		 				"type" : "Pet",
		 				"default-value" : "{ 'type' : 'Cat', age: 2 }"
		 			}
	 			]
	 		}
 		]
 	}
 \end{lstlisting}
 
The decoded representation of a migration guide is used by the \texttt{Migration} \texttt{Manager} subsystem to adapt previous facade code to the changes it contains. Although there are no off-the-shelf components that can be reused, patterns have been identified that are applicaple here. The behavior of the \texttt{Migration} component depends solely on the changes in the migration guide. Therefore, an alternative computational model is to be preferred in contrast to the common imperative models, in which code is organized in an object-oriented manner \cite{fowler_domain-specific_2011}. Fowler et. al coined the term \textit{Semantic Model} to define models that are populated by a \ac{DSL}.  The authors further define an \textit{Adaptive Model} as a specific variation of a Semantic Model in that they take the primary behavioral role in a system. According to the authors, Adaptive Models enable developers to shift the execution context from compile time to runtime and thus change behavior of a running system without a recompile. As the defined behavior is implicit, their implementation is difficult to understand and maintain \cite{fowler_domain-specific_2011}. The ability to alter the migration behavior during runtime by specifying changes in an external migration guide outweighs the negative aspects of using this pattern to model the \texttt{Migration} component. 

Before the generated source code emitted by the \texttt{Library} \texttt{Generation} and \texttt{Facade} \texttt{Generation} subsystems is persisted, users are able to specify formatting rules in order to fulfill \ref{nfr:CodeStyle}. Therefore, multiple open-source tools have been created for every modern programming language. SwiftFormat\footnote{https://github.com/apple/swift-format} is an open-source tool that formats Swift code using a predefined ruleset. It can be used either via \ac{CLI} or by integrating its framework into an existing Swift application. Prettier\footnote{https://prettier.io/} is a code formatter for multiple languages and dialects used in web development. It supports formatting of JavaScript, JSX, and TypeScript. Additionally, its active community provides plugins for even more languages like Java, Swift, and Ruby. Prettier can be integrated in \acp{IDE} or CI environments and provides an \ac{API} to be used within JavaScript applications. 

All subsystem that deal with importing or generating different types of programming languages or IDL documents are required to adapt their behavior based on the needs of the user. User preferences are provided by configuration options and need to be applied during runtime. The \textit{Strategy} pattern \cite{gamma_design_1995} is a behavioral design pattern that enables selecting these preferences without the need to recompile the application \cite{bruegge_object-oriented_2010}. In our proposed system we identified four subsystems that benefit from applying this pattern.

As shown in Figure \ref{fig:outcome}, our system emits library code that distinguishes between different layers that serve their own purpose. The library layer issues requests and receives responses directly from the Web API. It offers an interface to the facade layer that adapts to changes within the library layer without altering its own public interface. Client applications are unaware of the internal behavior of the facade layer and the interfaces of the library layer. The \textit{Facade} pattern \cite{gamma_design_1995} used here is a software design pattern that enables masking of internal behavior and any changes made to it.
 