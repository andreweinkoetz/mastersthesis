
@book{bass_software_2013,
  title = {Software Architecture in Practice},
  author = {Bass, Len and Clements, Paul and Kazman, Rick},
  year = {2013},
  edition = {3rd ed},
  publisher = {{Addison-Wesley}},
  address = {{Upper Saddle River, NJ}},
  isbn = {978-0-321-81573-6},
  keywords = {Software architecture,System design},
  lccn = {QA76.754 .B37 2013},
  series = {{{SEI}} Series in Software Engineering}
}

@article{benslimane_services_2008,
  title = {Services {{Mashups}}: {{The New Generation}} of {{Web Applications}}},
  shorttitle = {Services {{Mashups}}},
  author = {Benslimane, Djamal and Dustdar, Schahram and Sheth, Amit},
  year = {2008},
  month = sep,
  volume = {12},
  pages = {13--15},
  issn = {1089-7801},
  doi = {10.1109/MIC.2008.110},
  file = {/Users/andre/Zotero/storage/WHGCNZ4B/Benslimane et al. - 2008 - Services Mashups The New Generation of Web Applic.pdf},
  journal = {IEEE Internet Computing},
  number = {5}
}

@article{brito_you_2020,
  title = {You Broke My Code: Understanding the Motivations for Breaking Changes in {{APIs}}},
  shorttitle = {You Broke My Code},
  author = {Brito, Aline and Valente, Marco Tulio and Xavier, Laerte and Hora, Andre},
  year = {2020},
  month = mar,
  volume = {25},
  pages = {1458--1492},
  issn = {1382-3256, 1573-7616},
  doi = {10.1007/s10664-019-09756-z},
  abstract = {As most software systems, libraries and frameworks also evolve, which may break existing clients. However, the main reasons to introduce breaking changes in APIs are unclear. Therefore, in this paper, we first report the results of an almost 4-month long field study with popular Java libraries and frameworks. We configured an infrastructure to observe all changes in these libraries and to detect breaking changes shortly after their introduction in the code. We detected possible breaking changes in 61 projects. After identifying breaking changes, we asked the developers to explain the reasons behind their decision to change the APIs. By analyzing the developers' answers, we report that breaking changes are mostly motivated by the need to implement new features, by the desire to make the APIs simpler and with fewer elements, and to improve maintainability. To complement this first study, we describe a second study, including the analysis of 110 Stack Overflow posts related to breaking changes. We reveal that breaking changes have an important impact on clients, since 45\% of the questions are from clients asking how to overcome specific breaking changes; they are also common in other ecosystems\textemdash JavaScript, .NET, etc. We conclude by providing suggestions to language designers, tool builders, software engineering researchers, and API developers.},
  file = {/Users/andre/Zotero/storage/N7VXEBU9/Brito et al. - 2020 - You broke my code understanding the motivations f.pdf},
  journal = {Empirical Software Engineering},
  language = {en},
  number = {2}
}

@article{brown_refactoring_1998,
  title = {Refactoring {{Software}}, {{Architectures}}, and {{Projects}} in {{Crisis}}},
  author = {Brown, William J and Malveau, Raphael C and Iii, Hays W McCormick and Mowbray, Thomas J and Wiley, John and Ipsen, Robert and Hudson, Theresa},
  year = {1998},
  pages = {157},
  file = {/Users/andre/Zotero/storage/NLTKZ3MP/Brown et al. - Refactoring Software, Architectures, and Projects .pdf},
  language = {en}
}

@book{bruegge_object-oriented_2010,
  title = {Object-Oriented Software Engineering: Using {{UML}}, Patterns, and {{Java}}},
  shorttitle = {Object-Oriented Software Engineering},
  author = {Bruegge, Bernd and Dutoit, Allen H.},
  year = {2010},
  edition = {3rd ed},
  publisher = {{Prentice Hall}},
  address = {{Boston}},
  isbn = {978-0-13-606125-0},
  keywords = {Object-oriented programming (Computer science),Software engineering},
  lccn = {QA76.758 .B785 2010}
}

@book{carroll_scenario-based_1995,
  title = {Scenario-Based Design: Envisioning Work and Technology in System Development},
  shorttitle = {Scenario-Based Design},
  author = {Carroll, John M.},
  year = {1995},
  publisher = {{Wiley}},
  address = {{New York}},
  isbn = {978-0-471-07659-9},
  keywords = {System design,User interfaces (Computer systems)},
  lccn = {QA76.9.U83 S34 1995}
}

@inproceedings{eilertsen_exploring_2018,
  title = {Exploring {{API}}: Client Co-Evolution},
  shorttitle = {Exploring {{API}}},
  booktitle = {Proceedings of the 2nd {{International Workshop}} on {{API Usage}} and {{Evolution}}  - {{WAPI}} '18},
  author = {Eilertsen, Anna Maria and Bagge, Anya Helene},
  year = {2018},
  pages = {10--13},
  publisher = {{ACM Press}},
  address = {{Gothenburg, Sweden}},
  doi = {10.1145/3194793.3194799},
  abstract = {Software libraries evolve over time, as do their APIs and the clients that use them. Studying this co-evolution of APIs and API clients can give useful insights into both how to manage the co-evolution, and how to design software so that it is more resilient against API changes.},
  file = {/Users/andre/Zotero/storage/NUM84C2W/Eilertsen und Bagge - 2018 - Exploring API client co-evolution.pdf},
  isbn = {978-1-4503-5754-8},
  language = {en}
}

@inproceedings{espinha_web_2014,
  title = {Web {{API}} Growing Pains: {{Stories}} from Client Developers and Their Code},
  shorttitle = {Web {{API}} Growing Pains},
  booktitle = {2014 {{Software Evolution Week}} - {{IEEE Conference}} on {{Software Maintenance}}, {{Reengineering}}, and {{Reverse Engineering}} ({{CSMR}}-{{WCRE}})},
  author = {Espinha, Tiago and Zaidman, Andy and Gross, Hans-Gerhard},
  year = {2014},
  month = feb,
  pages = {84--93},
  publisher = {{IEEE}},
  address = {{Antwerp, Belgium}},
  doi = {10.1109/CSMR-WCRE.2014.6747228},
  abstract = {Web APIs provide a systematic and extensible approach for application-to-application interaction. Developers using web APIs are forced to accompany the API providers in their software evolution tasks. In order to understand the distress caused by this imposition on web API client developers we perform a semi-structured interview with six such developers. We also investigate how major web API providers organize their API evolution, and we explore how this affects source code changes of their clients. Our exploratory study of the Twitter, Google Maps, Facebook and Netflix web APIs analyzes the state of web API evolution practices and provides insight into the impact of service evolution on client software. Our study is complemented with a set of observations regarding best practices for web API evolution.},
  file = {/Users/andre/Zotero/storage/FZQ3CJTR/Espinha et al. - 2014 - Web API growing pains Stories from client develop.pdf},
  isbn = {978-1-4799-3752-3},
  language = {en}
}

@book{fowler_domain-specific_2011,
  title = {Domain-Specific Languages},
  author = {Fowler, Martin and Parsons, Rebecca},
  year = {2011},
  publisher = {{Addison-Wesley}},
  address = {{Upper Saddle River, NJ}},
  isbn = {978-0-321-71294-3},
  keywords = {Domain-specific programming languages,Programming languages (Electronic computers)},
  lccn = {QA76.7 .F687 2011}
}

@book{gamma_design_1995,
  title = {Design Patterns: Elements of Reusable Object-Oriented Software},
  shorttitle = {Design Patterns},
  editor = {Gamma, Erich},
  year = {1995},
  publisher = {{Addison-Wesley}},
  address = {{Reading, Mass}},
  isbn = {978-0-201-63361-0},
  keywords = {Computer software,Object-oriented programming (Computer science),Reusability,Software patterns},
  lccn = {QA76.64 .D47 1995},
  series = {Addison-{{Wesley}} Professional Computing Series}
}

@inproceedings{gerasimou_software_2018,
  title = {On Software Modernisation Due to Library Obsolescence},
  booktitle = {Proceedings of the 2nd {{International Workshop}} on {{API Usage}} and {{Evolution}} - {{WAPI}} '18},
  author = {Gerasimou, Simos and Kechagia, Maria and Kolovos, Dimitris and Paige, Richard and Gousios, Georgios},
  year = {2018},
  pages = {6--9},
  publisher = {{ACM Press}},
  address = {{Gothenburg, Sweden}},
  doi = {10.1145/3194793.3194798},
  abstract = {Software libraries, typically accessible through Application Programming Interfaces (APIs), enhance modularity and reduce development time. Nevertheless, their use reinforces system dependency on third-party software. When libraries become obsolete or their APIs change, performing the necessary modifications to dependent systems, can be time-consuming, labour intensive and error-prone. In this paper, we propose a methodology that reduces the effort developers must spend to mitigate library obsolescence. We describe the steps comprising the methodology, i.e., source code analysis, visualisation of hot areas, code-based transformation, and verification of the modified system. Also, we present some preliminary results and describe our plan for developing a fully automated software modernisation approach.},
  file = {/Users/andre/Zotero/storage/5MS9J727/Gerasimou et al. - 2018 - On software modernisation due to library obsolesce.pdf},
  isbn = {978-1-4503-5754-8},
  language = {en}
}

@inproceedings{henkel_catchup!_2005,
  title = {{{CatchUp}}! Capturing and Replaying Refactorings to Support {{API}} Evolution},
  booktitle = {Proceedings of the 27th International Conference on {{Software}} Engineering},
  author = {Henkel, Johannes and Diwan, Amer},
  year = {2005},
  month = may,
  pages = {274--283},
  publisher = {{Association for Computing Machinery}},
  address = {{St. Louis, MO, USA}},
  doi = {10.1145/1062455.1062512},
  abstract = {Library developers who have to evolve a library to accommodate changing requirements often face a dilemma: Either they implement a clean, efficient solution but risk breaking client code, or they maintain compatibility with client code, but pay with increased design complexity and thus higher maintenance costs over time.We address this dilemma by presenting a lightweight approach for evolving application programming interfaces (APIs), which does not depend on version control or configuration management systems. Instead, we capture API refactoring actions as a developer evolves an API. Users of the API can then replay the refactorings to bring their client software components up to date.We present catchup!, an implementation of our approach that captures and replays refactoring actions within an integrated development environment semi-automatically. Our experiments suggest that our approach could be valuable in practice.},
  file = {/Users/andre/Zotero/storage/GXU9SPKP/Henkel und Diwan - 2005 - CatchUp! capturing and replaying refactorings to s.pdf},
  isbn = {978-1-58113-963-1},
  keywords = {application programming interfaces,refactoring,software evolution},
  series = {{{ICSE}} '05}
}

@article{hora_how_2018,
  title = {How Do Developers React to {{API}} Evolution? {{A}} Large-Scale Empirical Study},
  shorttitle = {How Do Developers React to {{API}} Evolution?},
  author = {Hora, Andr{\'e} and Robbes, Romain and Valente, Marco Tulio and Anquetil, Nicolas and Etien, Anne and Ducasse, St{\'e}phane},
  year = {2018},
  month = mar,
  volume = {26},
  pages = {161--191},
  issn = {0963-9314, 1573-1367},
  doi = {10.1007/s11219-016-9344-4},
  abstract = {Software engineering research now considers that no system is an island, but it is part of an ecosystem involving other systems, developers, and users. When a framework or a library evolves, its clients often must adapt. For example, client developers might need to adapt to functionalities, client systems might need to be adapted to a new API, and client users might need to adapt to a new user interface. The consequences of these changes are yet unclear: what proportion of the ecosystem might be expected to react, how long might it take for a change to diffuse in the ecosystem, do all clients react in the same way? This paper reports an exploratory study aimed at observing API evolution and its impact on a large software ecosystem, Pharo, which has about 3600 distinct systems, and 6 years of evolution.},
  file = {/Users/andre/Zotero/storage/SVKN4843/Hora et al. - 2018 - How do developers react to API evolution A large-.pdf},
  journal = {Software Quality Journal},
  language = {en},
  number = {1}
}

@incollection{hutchison_automated_2006,
  title = {Automated {{Detection}} of {{Refactorings}} in {{Evolving Components}}},
  booktitle = {{{ECOOP}} 2006 \textendash{} {{Object}}-{{Oriented Programming}}},
  author = {Dig, Danny and Comertoglu, Can and Marinov, Darko and Johnson, Ralph},
  editor = {Hutchison, David and Kanade, Takeo and Kittler, Josef and Kleinberg, Jon M. and Mattern, Friedemann and Mitchell, John C. and Naor, Moni and Nierstrasz, Oscar and Pandu Rangan, C. and Steffen, Bernhard and Sudan, Madhu and Terzopoulos, Demetri and Tygar, Dough and Vardi, Moshe Y. and Weikum, Gerhard and Thomas, Dave},
  year = {2006},
  volume = {4067},
  pages = {404--428},
  publisher = {{Springer Berlin Heidelberg}},
  address = {{Berlin, Heidelberg}},
  doi = {10.1007/11785477_24},
  abstract = {One of the costs of reusing software components is updating applications to use the new version of the components. Updating an application can be error-prone, tedious, and disruptive of the development process. Our previous study showed that more than 80\% of the disruptive changes in five different components were caused by refactorings. If the refactorings that happened between two versions of a component could be automatically detected, a refactoring tool could replay them on applications. We present an algorithm that detects refactorings performed during component evolution. Our algorithm uses a combination of a fast syntactic analysis to detect refactoring candidates and a more expensive semantic analysis to refine the results. The experiments on components ranging from 17 KLOC to 352 KLOC show that our algorithm detects refactorings in real-world components with accuracy over 85\%.},
  file = {/Users/andre/Zotero/storage/XMAY43F2/Dig et al. - 2006 - Automated Detection of Refactorings in Evolving Co.pdf},
  isbn = {978-3-540-35726-1 978-3-540-35727-8},
  language = {en}
}

@book{jacobson_object-oriented_1992,
  title = {Object-Oriented Software Engineering: A Use Case Driven Approach},
  shorttitle = {Object-Oriented Software Engineering},
  author = {Jacobson, Ivar},
  year = {1992},
  publisher = {{ACM Press ; Addison-Wesley Pub}},
  address = {{[New York] : Wokingham, Eng. ; Reading, Mass}},
  isbn = {978-0-201-54435-0},
  keywords = {Computer software,Development,Object-oriented programming (Computer science)},
  lccn = {QA76.76.D47 O24 1992}
}

@book{jacobson_unified_1999,
  title = {The Unified Software Development Process},
  author = {Jacobson, Ivar and Booch, Grady and Rumbaugh, Jim},
  year = {1999},
  publisher = {{Addison-Wesley}},
  address = {{Reading, Massachusetts}},
  abstract = {Dieses Buch beschreibt die Konzepte des Rational Unified Process. Mit der Unified Modeling Language (UML) wird eine effiziente Notation zur Beschreibung von Softwaresystemen eingef\"uhrt. Der RUP beschreibt die Durchf\"uhrung eines Entwicklungsprojekts von der Planung bis hin zur Auslieferung.},
  annotation = {OCLC: 636807532},
  isbn = {978-0-201-57169-1 978-0-321-82200-0},
  language = {English}
}

@inproceedings{koci_classification_2019,
  title = {Classification of {{Changes}} in {{API Evolution}}},
  booktitle = {2019 {{IEEE}} 23rd {{International Enterprise Distributed Object Computing Conference}} ({{EDOC}})},
  author = {Koci, Rediana and Franch, Xavier and Jovanovic, Petar and Abello, Alberto},
  year = {2019},
  month = oct,
  pages = {243--249},
  publisher = {{IEEE}},
  address = {{Paris, France}},
  doi = {10.1109/EDOC.2019.00037},
  abstract = {Applications typically communicate with each other, accessing and exposing data and features by using Application Programming Interfaces (APIs). Even though API consumers expect APIs to be steady and well established, APIs are prone to continuous changes, experiencing different evolutive phases through their lifecycle. These changes are of different types, caused by different needs and are affecting consumers in different ways. In this paper, we identify and classify the changes that often happen to APIs, and investigate how all these changes are reflected in the documentation, release notes, issue tracker and API usage logs. The analysis of each step of a change, from its implementation to the impact that it has on API consumers, will help us to have a bigger picture of API evolution. Thus, we review the current state of the art in API evolution and, as a result, we define a classification framework considering both the changes that may occur to APIs and the reasons behind them. In addition, we exemplify the framework using a software platform offering a Web API, called District Health Information System (DHIS2), used collaboratively by several departments of World Health Organization (WHO).},
  file = {/Users/andre/Zotero/storage/4SR6AKJK/Koci et al. - 2019 - Classification of Changes in API Evolution.pdf},
  isbn = {978-1-72812-702-6},
  language = {en}
}

@inproceedings{li_how_2013,
  title = {How {{Does Web Service API Evolution Affect Clients}}?},
  booktitle = {2013 {{IEEE}} 20th {{International Conference}} on {{Web Services}}},
  author = {Li, Jun and Xiong, Yingfei and Liu, Xuanzhe and Zhang, Lu},
  year = {2013},
  month = jun,
  pages = {300--307},
  publisher = {{IEEE}},
  address = {{Santa Clara, CA, USA}},
  doi = {10.1109/ICWS.2013.48},
  abstract = {Like traditional local APIs, web service APIs (web APIs for short) evolve, bringing new and improved functionality as well as incompatibilities. Client programs have to be modified according to these changes in order to use the new APIs. Unlike client programs of a local API, which could continue to use the old API, clients of a web API often do not have the option not to upgrade, since the old version of the API may not be provided as a service anymore. Therefore, migrating clients of web APIs is a more critical task. Research has been done in the evolution of local APIs and different approaches have been proposed to support the migration of client applications. However, in practice, we seldom observe that web API providers release automated tools or services to assist the migration of client applications.},
  file = {/Users/andre/Zotero/storage/YLILE7JN/Li et al. - 2013 - How Does Web Service API Evolution Affect Clients.pdf},
  isbn = {978-0-7695-5025-1},
  language = {en}
}

@inproceedings{lubke_interface_2019,
  title = {Interface Evolution Patterns: Balancing Compatibility and Extensibility across Service Life Cycles},
  shorttitle = {Interface Evolution Patterns},
  booktitle = {Proceedings of the 24th {{European Conference}} on {{Pattern Languages}} of {{Programs}}  - {{EuroPLop}} '19},
  author = {L{\"u}bke, Daniel and Zimmermann, Olaf and Pautasso, Cesare and Zdun, Uwe and Stocker, Mirko},
  year = {2019},
  pages = {1--24},
  publisher = {{ACM Press}},
  address = {{Irsee, Germany}},
  doi = {10.1145/3361149.3361164},
  abstract = {Remote Application Programming Interfaces (APIs) are technology enablers for distributed systems and cloud-native application development. API providers find it hard to design their remote APIs so that they can be evolved easily; refactoring and extending an API while preserving backward compatibility is particularly challenging. If APIs are evolved poorly, clients are critically impacted; high costs to adapt and compensate for downtimes may result. For instance, if an API provider publishes a new incompatible API version, existing clients might break and not function properly until they are upgraded to support the new version. Hence, applying adequate strategies for evolving service APIs is one of the core problems in API governance, which in turn is a prerequisite for successfully integrating service providers with their clients in the long run. Although many patterns and pattern languages are concerned with API, service design, and related integration technologies, patterns guiding the evolution of APIs are missing to date. Extending our emerging pattern language on Microservice API Patterns (MAP), we introduce a set of patterns focusing on API evolution strategies in this paper: API Description, Version Identifier, Semantic Versioning, Eternal Lifetime Guarantee, Limited Lifetime Guarantee, Two in Production, Aggressive Obsolescence, and Experimental Preview. The patterns were mined from public Web APIs and industry projects the authors had been involved in.},
  file = {/Users/andre/Zotero/storage/56GDZSHL/LÃ¼bke et al. - 2019 - Interface evolution patterns balancing compatibil.pdf},
  isbn = {978-1-4503-6206-1},
  language = {en}
}

@misc{mckendrick_how_nodate,
  title = {How to Stay Ahead of Third-Party {{API}} Changes},
  author = {McKendrick, Joe},
  abstract = {'Sometimes previous API versions will stop working completely, leaving you with a client code that is making calls to dead endpoints.'},
  file = {/Users/andre/Zotero/storage/3E55WWNW/how-to-stay-ahead-of-third-party-api-changes.html},
  howpublished = {https://www.zdnet.com/article/how-to-stay-ahead-of-third-party-api-changes/},
  journal = {ZDNet},
  language = {en}
}

@inproceedings{nita_using_2010,
  title = {Using Twinning to Adapt Programs to Alternative {{APIs}}},
  booktitle = {Proceedings of the 32nd {{ACM}}/{{IEEE International Conference}} on {{Software Engineering}} - {{Volume}} 1},
  author = {Nita, Marius and Notkin, David},
  year = {2010},
  month = may,
  pages = {205--214},
  publisher = {{Association for Computing Machinery}},
  address = {{Cape Town, South Africa}},
  doi = {10.1145/1806799.1806832},
  abstract = {We describe twinning and its applications to adapting programs to alternative APIs. Twinning is a simple technique that allows programmers to specify a class of program changes, in the form of a mapping, without modifying the target program directly. Using twinning, programmers can specify changes that transition a program from using one API to using an alternative API. We describe two related mapping-based source-to-source transformations. The first applies the mapping to a program, producing a copy with the changes applied. The second generates a new API that abstracts the changes specified in the mapping. Using this API, programmers can invoke either the old (replaced) code or the new (replacement) code through a single interface. Managing program variants usually involves heavyweight tasks that can prevent the program from compiling for extended periods of time, as well as simultaneous maintenance of multiple implementations, which can make it easy to forget to add features or to fix bugs symmetrically. Our main contribution is to show that, at least in some common cases, the heavyweight work can be reduced and symmetric maintenance can be at least encouraged, and often enforced.},
  file = {/Users/andre/Zotero/storage/9JJND4VC/Nita und Notkin - 2010 - Using twinning to adapt programs to alternative AP.pdf},
  isbn = {978-1-60558-719-6},
  keywords = {API mapping,source-to-source translation,twinning},
  series = {{{ICSE}} '10}
}

@misc{noauthor_api_nodate,
  title = {{{API}} Tooling Development: {{GraphQL}}, {{OpenAPI}} | {{APIs}}.Guru},
  shorttitle = {{{API}} Tooling Development},
  abstract = {API tooling for better developer experience. We create tools to help developers workwith GraphQL and OpenAPI/Swagger.},
  file = {/Users/andre/Zotero/storage/NEYW9PFA/apis.guru.html},
  howpublished = {https://APIs.guru/},
  journal = {APIs.guru - Wikipedia for WEB APIs}
}

@article{ogheneovo_relationship_2014,
  title = {On the {{Relationship}} between {{Software Complexity}} and {{Maintenance Costs}}},
  author = {Ogheneovo, Edward E.},
  year = {2014},
  volume = {02},
  pages = {1--16},
  issn = {2327-5219, 2327-5227},
  doi = {10.4236/jcc.2014.214001},
  abstract = {As software becomes more and more complex due to increased number of module size, procedure size, and branching complexity, software maintenance costs are often on the increase. Consider a software such as Windows 2000 operating systems with over 29 million lines of code (LOC), 480,000 pages if printed, a stack of paper 161 feet high, estimate of 63,000 bugs in the software when it was first released [1] and with over 1000 developers, there is no doubt that such a large and complex software will require large amount of money (in US Dollars), social and environmental factors to maintain it. It has been estimated that over 70\% of the total costs of software development process is expended on maintenance after the software has been delivered. This paper studies the relationship between software complexity and maintenance cost, the factors responsible for software complexity and why maintenance costs increase with software complexity. Some data collected on Windows, Debian Linux, and Linux Kernel operating systems were used. The results of our findings show that there is a strong correlation between software complexity and maintenance costs. That is, as lines of code increase, the software becomes more complex and more bugs may be introduced, and hence the cost of maintaining software increases.},
  file = {/Users/andre/Zotero/storage/82E4MEMC/Ogheneovo - 2014 - On the Relationship between Software Complexity an.pdf},
  journal = {Journal of Computer and Communications},
  language = {en},
  number = {14}
}

@article{sawant_react_2019,
  title = {To React, or Not to React: {{Patterns}} of Reaction to {{API}} Deprecation},
  shorttitle = {To React, or Not to React},
  author = {Sawant, Anand Ashok and Robbes, Romain and Bacchelli, Alberto},
  year = {2019},
  month = dec,
  volume = {24},
  pages = {3824--3870},
  issn = {1382-3256, 1573-7616},
  doi = {10.1007/s10664-019-09713-w},
  abstract = {Application Programming Interfaces (API) provide reusable functionality to aid developers in the development process. The features provided by these APIs might change over time as the API evolves. To allow API consumers to peacefully transition from older obsolete features to new features, API producers make use of the deprecation mechanism that allows them to indicate to the consumer that a feature should no longer be used. The Java language designers noticed that no one was taking these deprecation warnings seriously and continued using outdated features. Due to this, they decided to change the implementation of this feature in Java 9. We question as to what extent this issue exists and whether the Java language designers have a case. We start by identifying the various ways in which an API consumer can react to deprecation. Following this we benchmark the frequency of the reaction patterns by creating a dataset consisting of data mined from 50 API consumers totalling 297,254 GitHub based projects and 1,322,612,567 type-checked method invocations. We see that predominantly consumers do not react to deprecation and we try to explain this behavior by surveying API consumers and by analyzing if the API's deprecation policy has an impact on the consumers' decision to react.},
  file = {/Users/andre/Zotero/storage/LCH4VWMI/Sawant et al. - 2019 - To react, or not to react Patterns of reaction to.pdf},
  journal = {Empirical Software Engineering},
  language = {en},
  number = {6}
}

@inproceedings{schwichtenberg_open_2017,
  title = {From {{Open API}} to {{Semantic Specifications}} and {{Code Adapters}}},
  booktitle = {2017 {{IEEE International Conference}} on {{Web Services}} ({{ICWS}})},
  author = {Schwichtenberg, Simon and Gerth, Christian and Engels, Gregor},
  year = {2017},
  month = jun,
  pages = {484--491},
  publisher = {{IEEE}},
  address = {{Honolulu, HI, USA}},
  doi = {10.1109/ICWS.2017.56},
  abstract = {Today, modern IT-systems are often an interplay of third-party web services. Developers in their role as requesters integrate existing services of different providers into new IT-systems. Providers use frameworks like Open API to create syntactic service specifications from which requesters generate code to integrate services. Proper service discovery is crucial to identify usable services in the growing plethora of third-party services. Most advanced service discovery approaches rely on semantic specifications, e.g., OWL-S. While semantic specifications are crucial for a precise discovery, syntactical specification are needed for service invocation. To close the gap between semantic and syntactic specifications, service grounding establishes links between the semantic and syntactic specifications. However, for a large number of web services still no semantic specification or grounding exists.},
  file = {/Users/andre/Zotero/storage/A82I3KDR/Schwichtenberg et al. - 2017 - From Open API to Semantic Specifications and Code .pdf},
  isbn = {978-1-5386-0752-7},
  language = {en}
}

@book{steiner_supervisor_2007,
  title = {Supervisor},
  author = {Steiner, Thomas and Dr, Prof and Calmet, Jacques and Chanezon, Patrick and Steiner, Thomas},
  year = {2007},
  abstract = {Statement of originality Hereby I declare this thesis to be the work of my own, written independently. All sources and references are correctly cited with complete references to their sources.},
  file = {/Users/andre/Zotero/storage/4VGAMS3L/Steiner et al. - 2007 - Supervisor.pdf;/Users/andre/Zotero/storage/CYWA4CKB/summary.html}
}

@inproceedings{xavier_historical_2017,
  title = {Historical and Impact Analysis of {{API}} Breaking Changes: {{A}} Large-Scale Study},
  shorttitle = {Historical and Impact Analysis of {{API}} Breaking Changes},
  booktitle = {2017 {{IEEE}} 24th {{International Conference}} on {{Software Analysis}}, {{Evolution}} and {{Reengineering}} ({{SANER}})},
  author = {Xavier, Laerte and Brito, Aline and Hora, Andre and Valente, Marco Tulio},
  year = {2017},
  month = feb,
  pages = {138--147},
  publisher = {{IEEE}},
  address = {{Klagenfurt, Austria}},
  doi = {10.1109/SANER.2017.7884616},
  abstract = {Change is a routine in software development. Like any system, libraries also evolve over time. As a consequence, clients are compelled to update and, thus, benefit from the available API improvements. However, some of these API changes may break contracts previously established, resulting in compilation errors and behavioral changes. In this paper, we study a set of questions regarding API breaking changes. Our goal is to measure the amount of breaking changes on real-world libraries and its impact on clients at a large-scale level. We assess (i) the frequency of breaking changes, (ii) the behavior of these changes over time, (iii) the impact on clients, and (iv) the characteristics of libraries with high frequency of breaking changes. Our largescale analysis on 317 real-world Java libraries, 9K releases, and 260K client applications shows that (i) 14.78\% of the API changes break compatibility with previous versions, (ii) the frequency of breaking changes increases over time, (iii) 2.54\% of their clients are impacted, and (iv) systems with higher frequency of breaking changes are larger, more popular, and more active. Based on these results, we provide a set of lessons to better support library and client developers in their maintenance tasks.},
  file = {/Users/andre/Zotero/storage/AYUBYZFG/Xavier et al. - 2017 - Historical and impact analysis of API breaking cha.pdf},
  isbn = {978-1-5090-5501-2},
  language = {en}
}

@article{zdun_emerging_2020,
  title = {Emerging {{Trends}}, {{Challenges}}, and {{Experiences}} in {{DevOps}} and {{Microservice APIs}}},
  author = {Zdun, Uwe and Wittern, Erik and Leitner, Philipp},
  year = {2020},
  month = jan,
  volume = {37},
  pages = {87--91},
  issn = {0740-7459, 1937-4194},
  doi = {10.1109/MS.2019.2947982},
  file = {/Users/andre/Zotero/storage/5VCRCZXA/Zdun et al. - 2020 - Emerging Trends, Challenges, and Experiences in De.pdf},
  journal = {IEEE Software},
  language = {en},
  number = {1}
}


